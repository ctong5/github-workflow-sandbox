# ==============================
# Sync main branch to develop branch
# On push to main, create/update PR to develop
# Auto-merge PR with merge commit
# ==============================

name: Sync main to develop

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  actions: read

# Only one sync job at a time; cancel in-progress on new pushes
concurrency:
  group: sync-main-to-develop
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute sync metadata
        id: syncmeta
        env:
          EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail
          SYNC_BRANCH='sync/main-to-develop'

          # Short SHA (12 chars) for traceability
          if [ "${EVENT_NAME}" = "workflow_dispatch" ]; then
            git fetch --quiet origin main
            SHORT_SHA="$(git rev-parse --short=12 origin/main)"
          else
            SHORT_SHA="${GITHUB_SHA:0:12}"
          fi

          echo "SYNC_BRANCH=${SYNC_BRANCH}" >> "${GITHUB_OUTPUT}"
          echo "SHORT_SHA=${SHORT_SHA}"     >> "${GITHUB_OUTPUT}"

      - name: Open (or reuse) sync/main-to-develop PR with description
        env:
          SYNC_BRANCH: ${{ steps.syncmeta.outputs.SYNC_BRANCH }}
          SHORT_SHA:   ${{ steps.syncmeta.outputs.SHORT_SHA }}
          GH_TOKEN:    ${{ secrets.GITHUB_TOKEN }}
          REPO:        ${{ github.repository }}
          BEFORE:      ${{ github.event.before }}   # empty for workflow_dispatch
          AFTER:       ${{ github.sha }}            # the pushed SHA on main
        run: |
          set -euo pipefail

          BODY_FILE="${RUNNER_TEMP}/sync_pr_body.md"
          REPO_URL="https://github.com/${REPO}"
          : > "${BODY_FILE}"

          echo "Automated PR to sync **main** into **develop**." >> "${BODY_FILE}"
          echo "" >> "${BODY_FILE}"

          # Latest on main: prefer PR title + link; else commit subject + link
          LATEST_LINE=""
          if [ -n "${AFTER:-}" ]; then
            PR_JSON="$(gh api "repos/${REPO}/commits/${AFTER}/pulls" \
                        -H "Accept: application/vnd.github.groot-preview+json" || true)"
            PR_NUM="$(echo "${PR_JSON}" | jq -r '.[0].number // empty')"
            if [ -n "${PR_NUM}" ]; then
              PR_TITLE="$(echo "${PR_JSON}" | jq -r '.[0].title')"
              LATEST_LINE="Latest on main: ${PR_TITLE} ([#${PR_NUM}](${REPO_URL}/pull/${PR_NUM}))"
            else
              SUBJECT="$(gh api "repos/${REPO}/commits/${AFTER}" --jq '.commit.message | split("\n")[0]' || true)"
              SHORT_AFTER="${AFTER:0:7}"
              LATEST_LINE="Latest on main: ${SUBJECT} ([${SHORT_AFTER}](${REPO_URL}/commit/${AFTER}))"
            fi
          fi
          [ -n "${LATEST_LINE}" ] && echo "${LATEST_LINE}" >> "${BODY_FILE}"

          # Commits in this sync (PR titles when possible; fallback to commit subjects)
          if [ -n "${BEFORE:-}" ] && [ -n "${AFTER:-}" ]; then
            echo "" >> "${BODY_FILE}"
            echo "Commits in this sync:" >> "${BODY_FILE}"

            # Try Compare API first
            COUNT="$(gh api "repos/${REPO}/compare/${BEFORE}...${AFTER}" --jq '.commits | length' 2>/dev/null || echo 0)"

            if [ "${COUNT}" -gt 0 ]; then
              SHAS="$(gh api "repos/${REPO}/compare/${BEFORE}...${AFTER}" --jq '.commits[].sha' 2>/dev/null || true)"
              PRINTED_ANY="false"
              while IFS= read -r SHA; do
                [ -z "${SHA}" ] && continue
                PRS="$(gh api "repos/${REPO}/commits/${SHA}/pulls" \
                        -H "Accept: application/vnd.github.groot-preview+json" 2>/dev/null || true)"
                PRN="$(echo "${PRS}" | jq -r '.[0].number // empty')"
                if [ -n "${PRN}" ]; then
                  PRT="$(echo "${PRS}" | jq -r '.[0].title')"
                  echo "* ${PRT} ([#${PRN}](${REPO_URL}/pull/${PRN}))" >> "${BODY_FILE}"
                  PRINTED_ANY="true"
                else
                  SUBJ="$(gh api "repos/${REPO}/commits/${SHA}" --jq '.commit.message | split("\n")[0]' 2>/dev/null || true)"
                  SHORT_SHA7="${SHA:0:7}"
                  [ -n "${SUBJ}" ] && echo "* ${SHORT_SHA7}: ${SUBJ}" >> "${BODY_FILE}" && PRINTED_ANY="true"
                fi
              done <<EOF
              ${SHAS}
              EOF
              if [ "${PRINTED_ANY}" != "true" ]; then
                if [ -n "${PR_NUM:-}" ]; then
                  echo "* ${PR_TITLE} ([#${PR_NUM}](${REPO_URL}/pull/${PR_NUM}))" >> "${BODY_FILE}"
                elif [ -n "${SUBJECT:-}" ]; then
                  SHORT_AFTER="${AFTER:0:7}"
                  echo "* ${SHORT_AFTER}: ${SUBJECT}" >> "${BODY_FILE}"
                fi
              fi
            else
              # Fallback: associate the AFTER merge commit with its PR and list those commits
              PR_INFO="$(gh api "repos/${REPO}/commits/${AFTER}/pulls" \
                          -H "Accept: application/vnd.github.groot-preview+json" \
                          --jq '.[0] | "\(.number)|\(.title)"' 2>/dev/null || true)"
              if [ -n "${PR_INFO}" ]; then
                IFS='|' read -r PRNUM_FALLBACK PRTITLE_FALLBACK <<< "${PR_INFO}"
                echo "* ${PRTITLE_FALLBACK} ([#${PRNUM_FALLBACK}](${REPO_URL}/pull/${PRNUM_FALLBACK}))" >> "${BODY_FILE}"
                # (Optional) enumerate commits in the PR if you want a full list:
                # gh api "repos/${REPO}/pulls/${PRNUM_FALLBACK}/commits" --paginate \
                #   --jq '.[] | "* \(.sha[0:7]): \(.commit.message | split("\n")[0])"' >> "${BODY_FILE}" || true
              else
                SHORT_AFTER="${AFTER:0:7}"
                [ -n "${SUBJECT:-}" ] && echo "* ${SHORT_AFTER}: ${SUBJECT}" >> "${BODY_FILE}"
              fi
            fi
          fi

          # Full changelog link
          if [ -n "${BEFORE:-}" ] && [ -n "${AFTER:-}" ]; then
            echo "" >> "${BODY_FILE}"
            SHORT_BEFORE="${BEFORE:0:7}"
            SHORT_AFTER="${AFTER:0:7}"
            echo "Full Changelog: [${SHORT_BEFORE}...${SHORT_AFTER}](${REPO_URL}/compare/${BEFORE}...${AFTER})" >> "${BODY_FILE}"
          fi

          # Open or reuse the PR
          EXISTING="$(gh pr list --repo "${REPO}" --base develop --head "${SYNC_BRANCH}" --state open --json number --jq '.[0].number // empty')"

          if [ -n "${EXISTING}" ]; then
            PR_NUMBER="${EXISTING}"
            gh pr edit "${PR_NUMBER}" --repo "${REPO}" \
              --title "Sync main to develop (${SHORT_SHA})" \
              --body-file "${BODY_FILE}"
          else
            gh pr create \
              --repo  "${REPO}" \
              --base  develop \
              --head  "${SYNC_BRANCH}" \
              --title "Sync main -> develop (${SHORT_SHA})" \
              --body-file "${BODY_FILE}"
            PR_NUMBER="$(gh pr list --repo "${REPO}" --base develop --head "${SYNC_BRANCH}" --state open --json number --jq '.[0].number')"
          fi

          echo "PR_NUMBER=${PR_NUMBER}" >> "${GITHUB_ENV}"
   
      - name: Wait for mergeability to be confirmed (avoid UNSTABLE/UNKNOWN flakey states)
        if: env.PR_NUMBER != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          for i in {1..24}; do
            state=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json mergeStateStatus --jq .mergeStateStatus)
            echo "mergeStateStatus=$state"
            [[ "$state" =~ ^(UNKNOWN|UNSTABLE)$ ]] && sleep 5 || break
          done

      - name: Enable auto-merge (merge commit) with retry
        if: env.PR_NUMBER != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          for i in {1..6}; do
            if gh pr merge "$PR_NUMBER" --repo "$REPO" --merge --auto; then
              echo "Auto-merge enabled (merge commit)."
              exit 0
            fi
            echo "Auto-merge not enableable yet (attempt $i); retrying in 10s..."
            sleep 10
          done
          echo "::error::Failed to enable auto-merge after retries."
          exit 1
